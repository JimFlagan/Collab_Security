# Buffer Overflow Terms
| Name | Descrition |
| - | - |
|Heap|Memory that can be allocated and deallocated|
|Stack|A contiguous section of memory used for passing arguments|
|Registers|Storage elements as close as possible to the central processing unit (CPU)|
|Instruction Pointer (IP)|a.k.a Program Counter (PC), contains the address of next instruction to be executed|
|Stack Pointer (SP)|Contains the address of the next available space on the stack|
|Base Pointer (BP)|The base of the stack|
|Function|Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient|
|Shellcode|The code that is executed once an exploit successfully takes advantage of a vulnerability|

# Buffer Overflow Defenses
-Non executable (NX) stack
-Address Space Layout Randomization (ASLR)
- Data Execution Prevention (DEP)
- Stack Canaries
- Position Independent Executable (PIE)

# Peda
Installation:
```
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
```
Common Commands:
```
disass <FUNCTION>   #   Disassemble portion of the program
info <...>  #   Supply info for specific stack areas
x/256c $<REGISTER>  #   Read characters from specific register
break <address>  #   Establish a break point
```
# Exploit Testing
## Step 1. Does it take arguments?
```
./func $(echo "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
```
## Step 2. Bash String Insertion
```
./func <<< $(echo "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
```
The `<<<` is a way of mimicking user input in bash
## Step 3. String Insertion Via Script
You can write a python script that outputs the contents of a buffer:
```
#!/usr/bin/env python
# linbuffer.py
buffer = "A" * 50
print(buffer)
```
then we can send the input to the executable:
```
./func <<< $(./linbuffer.py)
```
Modifying the buffer size can test where a segmentation fault is, in this case a buffer of 75 yields this result:
```
student@lin-ops:~$ ./func <<< $(./linbuffer.py)
Enter a string: 
Segmentation fault (core dumped)
```
This is a result of overflowing the input buffer and overwriting the actual assembly commands
## Step 4. GDB w/ Peda
Start with `run ./func` or whatever your executable name is

Useful Commands:
- `shell` opens a linux shell that can be closed with `exit`
- `info` which gives info on various items, `info function` shows all functions
- `disass` disassembles a function specify it with (I.E: `disass getuserinput`)

Note:
- Red highlighting shows vulnerable parts of the code

Example Output:

![image](https://github.com/user-attachments/assets/fbf21eb2-20fe-4428-b41e-a3ee0160a278)

## Step 5. Inside GDB repeat step 3
Example command:
```
run <<<$(./linbuffer.py)
```
Output:

![image](https://github.com/user-attachments/assets/d553aabe-d29b-441e-8f87-06b9d0a9d5ea)

This shows the buffer overflow starting at instruction at `0x41414141` because "AAAA" has overrode the EIX or instruction pointer, meaning that it points to `0x41414141` (A is ASCII 0x41)
